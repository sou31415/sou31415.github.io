<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<title>ABC294 log</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<center>
		<h2><a href="../index.html">AtCoder Stack</a></h2>
	</center>
	<ul class="accordion-area">
		<li>
			<section>
				<h3 class="title">A - Filter</h3>
				<div class="box">
					<p><a href="https://atcoder.jp/contests/abc294/tasks/abc294_a">Problem</a><br>
					Iteratorゴリ押し。.iter().filter(|x| x % 2 == 0)for文をまわして出力する。<br><a href="https://atcoder.jp/contests/abc294/submissions/39980541">A:submission</a>
					</p>
				</div>
			</section>
		</li>
		<li>
			<section>
				<h3 class="title">B - ASCII Art</h3>
				<div class="box">
					<p><a href="https://atcoder.jp/contests/abc294/tasks/abc294_b">Problem</a><br>
					お馴染みの'A' as u8 - 1芸。<i>a[i][j]</i>を足してcharにして出力する。0の時.を出力する、改行の位置に気をつける。<br><a href="https://atcoder.jp/contests/abc294/submissions/39849252">B:submission</a>
					</p>
				</div>
			</section>
		</li>
		<li>
			<section>
				<h3 class="title">C - Merge Seauences</h3>
				<div class="box">
					<p><a href="https://atcoder.jp/contests/abc294/tasks/abc294_c">Problem</a><br>
					AはAで、BはBでそれぞれusizeの配列を持たせる。全ての値を入れたベクタに一つずつpushしていき、最後にsortする。何番目に含まれているかはベクタのbinary_search(&K)で返されてきたResult型の値をunwrapすることにより得られる。Kが含まれていることは自明なのでif letを使って慎重にならなくても良い、という判断。全体の計算量は多く見積もってもせいぜい<i>O((N+M)+2(N+M)log(N+M))</i>程度であり、じゅうぶん高速に動作する。binary_searchで得られた値は0-based indexで返されるため1-based indexにするために+1することを忘れてはいけない。<br><a href="https://atcoder.jp/contests/abc294/submissions/39855519">C:submission</a>
					</p>
				</div>
			</section>
		</li>
		<li>
			<section>
				<h3 class="title">D - Bank</h3>
				<div class="box">
					<p><a href="https://atcoder.jp/contests/abc294/tasks/abc294_d">Problem</a><br>
					呼ばれてない人をqueで管理して呼ばれたがいってない人をvecで管理し、いった人をbinary_searchを使って<i>O(logN)</i>でindexを探索し、探索したindexの要素を<i>O(N)</i>で消す、ということをしていたらTLEになってしまった。結局HashSetをB木で管理、実装しているBTreeSetを使うことによって実装,ACできた。呼ばれてない人をqueで管理するのはそのままに、いってない人をBTreeSetで管理した。1の時que.pop_front().unwrap()したものをBTreeSetにinsert、2の時xをUsize1で取得し、remove(&x)でいってない人の中からxを消す、3の時BTreeSet.iter().next().unwrap()でBTreeSetの中で最も小さい人を取り出せる。0-based indexを1-based indexにするために+1する。<br><a href="https://atcoder.jp/contests/abc294/submissions/39906118">D:submission</a>
					</p>
				</div>
			</section>
		</li>
	</ul>
	<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
	<script src="./index.js"></script>
</body>
